namespace IronJS.Api

//------------------------------------------------------------------------------
// This file is generated by T4 and will be reset on each compile
//------------------------------------------------------------------------------

open System
open IronJS

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
type [<Sealed>] Object = 

  //----------------------------------------------------------------------------
  static member putProperty (x:IjsObj, name:IjsStr, value:IjsBox byref) =
    let index = Object.createPropertyIndex(x, name)
    x.PropertyValues.[index] <- value
    value

  //----------------------------------------------------------------------------
  static member putProperty (x:IjsObj, name:IjsStr, value:IjsBool) =
    let index = Object.createPropertyIndex(x, name)
    Utils.setIjsBoolInArray x.PropertyValues index value
    value

  //----------------------------------------------------------------------------
  static member putProperty (x:IjsObj, name:IjsStr, value:IjsNum) =
    let index = Object.createPropertyIndex(x, name)
    Utils.setIjsNumInArray x.PropertyValues index value
    value

  //----------------------------------------------------------------------------
  static member putProperty (x:IjsObj, name:IjsStr, value:HostObject) =
    let index = Object.createPropertyIndex(x, name)
    Utils.setHostObjectInArray x.PropertyValues index value
    value

  //----------------------------------------------------------------------------
  static member putProperty (x:IjsObj, name:IjsStr, value:Undefined) =
    let index = Object.createPropertyIndex(x, name)
    Utils.setUndefinedInArray x.PropertyValues index value
    value

  //----------------------------------------------------------------------------
  static member putProperty (x:IjsObj, name:IjsStr, value:IjsStr) =
    let index = Object.createPropertyIndex(x, name)
    Utils.setIjsStrInArray x.PropertyValues index value
    value

  //----------------------------------------------------------------------------
  static member putProperty (x:IjsObj, name:IjsStr, value:IjsObj) =
    let index = Object.createPropertyIndex(x, name)
    Utils.setIjsObjInArray x.PropertyValues index value
    value

  //----------------------------------------------------------------------------
  static member putProperty (x:IjsObj, name:IjsStr, value:IjsFunc) =
    let index = Object.createPropertyIndex(x, name)
    Utils.setIjsFuncInArray x.PropertyValues index value
    value

  //----------------------------------------------------------------------------
  static member putLength (x:IjsObj, value:IjsBox byref) : IjsBox =
    Object.updateLength(x, TypeConverter.toNumber &value)
    Object.putProperty(x, "length", &value)

  //----------------------------------------------------------------------------
  static member putLength (x:IjsObj, value:IjsBool) : IjsBool =
    Object.updateLength(x, TypeConverter.toNumber value)
    Object.putProperty(x, "length", value)

  //----------------------------------------------------------------------------
  static member putLength (x:IjsObj, value:IjsNum) : IjsNum =
    Object.updateLength(x, TypeConverter.toNumber value)
    Object.putProperty(x, "length", value)

  //----------------------------------------------------------------------------
  static member putLength (x:IjsObj, value:HostObject) : HostObject =
    Object.updateLength(x, TypeConverter.toNumber value)
    Object.putProperty(x, "length", value)

  //----------------------------------------------------------------------------
  static member putLength (x:IjsObj, value:Undefined) : Undefined =
    Object.updateLength(x, TypeConverter.toNumber value)
    Object.putProperty(x, "length", value)

  //----------------------------------------------------------------------------
  static member putLength (x:IjsObj, value:IjsStr) : IjsStr =
    Object.updateLength(x, TypeConverter.toNumber value)
    Object.putProperty(x, "length", value)

  //----------------------------------------------------------------------------
  static member putLength (x:IjsObj, value:IjsObj) : IjsObj =
    Object.updateLength(x, TypeConverter.toNumber value)
    Object.putProperty(x, "length", value)

  //----------------------------------------------------------------------------
  static member putLength (x:IjsObj, value:IjsFunc) : IjsFunc =
    Object.updateLength(x, TypeConverter.toNumber value)
    Object.putProperty(x, "length", value)

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:Box byref, value:IjsBox byref) : IjsBox = 
    match index.Type with
    | TypeCodes.Number -> Object.putIndex(x, index.Double, &value)
    | TypeCodes.String -> Object.putIndex(x, index.String, &value)
    | TypeCodes.Undefined -> Object.putProperty(x, "undefined", &value)
    | TypeCodes.Object
    | TypeCodes.Function ->
      let mutable v = Object.defaultValue(index.Object)
      Object.putIndex(x, &v, &value)

    | TypeCodes.Bool ->
      Object.putProperty(x, TypeConverter.toString index.Bool, &value)

    | TypeCodes.Clr -> 
      Object.putProperty(x, TypeConverter.toString index.Clr, &value)

    | _ -> failwith "Que?"

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:Box byref, value:IjsBool) : IjsBool = 
    match index.Type with
    | TypeCodes.Number -> Object.putIndex(x, index.Double, value)
    | TypeCodes.String -> Object.putIndex(x, index.String, value)
    | TypeCodes.Undefined -> Object.putProperty(x, "undefined", value)
    | TypeCodes.Object
    | TypeCodes.Function ->
      let mutable v = Object.defaultValue(index.Object)
      Object.putIndex(x, &v, value)

    | TypeCodes.Bool ->
      Object.putProperty(x, TypeConverter.toString index.Bool, value)

    | TypeCodes.Clr -> 
      Object.putProperty(x, TypeConverter.toString index.Clr, value)

    | _ -> failwith "Que?"

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:Box byref, value:IjsNum) : IjsNum = 
    match index.Type with
    | TypeCodes.Number -> Object.putIndex(x, index.Double, value)
    | TypeCodes.String -> Object.putIndex(x, index.String, value)
    | TypeCodes.Undefined -> Object.putProperty(x, "undefined", value)
    | TypeCodes.Object
    | TypeCodes.Function ->
      let mutable v = Object.defaultValue(index.Object)
      Object.putIndex(x, &v, value)

    | TypeCodes.Bool ->
      Object.putProperty(x, TypeConverter.toString index.Bool, value)

    | TypeCodes.Clr -> 
      Object.putProperty(x, TypeConverter.toString index.Clr, value)

    | _ -> failwith "Que?"

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:Box byref, value:HostObject) : HostObject = 
    match index.Type with
    | TypeCodes.Number -> Object.putIndex(x, index.Double, value)
    | TypeCodes.String -> Object.putIndex(x, index.String, value)
    | TypeCodes.Undefined -> Object.putProperty(x, "undefined", value)
    | TypeCodes.Object
    | TypeCodes.Function ->
      let mutable v = Object.defaultValue(index.Object)
      Object.putIndex(x, &v, value)

    | TypeCodes.Bool ->
      Object.putProperty(x, TypeConverter.toString index.Bool, value)

    | TypeCodes.Clr -> 
      Object.putProperty(x, TypeConverter.toString index.Clr, value)

    | _ -> failwith "Que?"

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:Box byref, value:Undefined) : Undefined = 
    match index.Type with
    | TypeCodes.Number -> Object.putIndex(x, index.Double, value)
    | TypeCodes.String -> Object.putIndex(x, index.String, value)
    | TypeCodes.Undefined -> Object.putProperty(x, "undefined", value)
    | TypeCodes.Object
    | TypeCodes.Function ->
      let mutable v = Object.defaultValue(index.Object)
      Object.putIndex(x, &v, value)

    | TypeCodes.Bool ->
      Object.putProperty(x, TypeConverter.toString index.Bool, value)

    | TypeCodes.Clr -> 
      Object.putProperty(x, TypeConverter.toString index.Clr, value)

    | _ -> failwith "Que?"

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:Box byref, value:IjsStr) : IjsStr = 
    match index.Type with
    | TypeCodes.Number -> Object.putIndex(x, index.Double, value)
    | TypeCodes.String -> Object.putIndex(x, index.String, value)
    | TypeCodes.Undefined -> Object.putProperty(x, "undefined", value)
    | TypeCodes.Object
    | TypeCodes.Function ->
      let mutable v = Object.defaultValue(index.Object)
      Object.putIndex(x, &v, value)

    | TypeCodes.Bool ->
      Object.putProperty(x, TypeConverter.toString index.Bool, value)

    | TypeCodes.Clr -> 
      Object.putProperty(x, TypeConverter.toString index.Clr, value)

    | _ -> failwith "Que?"

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:Box byref, value:IjsObj) : IjsObj = 
    match index.Type with
    | TypeCodes.Number -> Object.putIndex(x, index.Double, value)
    | TypeCodes.String -> Object.putIndex(x, index.String, value)
    | TypeCodes.Undefined -> Object.putProperty(x, "undefined", value)
    | TypeCodes.Object
    | TypeCodes.Function ->
      let mutable v = Object.defaultValue(index.Object)
      Object.putIndex(x, &v, value)

    | TypeCodes.Bool ->
      Object.putProperty(x, TypeConverter.toString index.Bool, value)

    | TypeCodes.Clr -> 
      Object.putProperty(x, TypeConverter.toString index.Clr, value)

    | _ -> failwith "Que?"

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:Box byref, value:IjsFunc) : IjsFunc = 
    match index.Type with
    | TypeCodes.Number -> Object.putIndex(x, index.Double, value)
    | TypeCodes.String -> Object.putIndex(x, index.String, value)
    | TypeCodes.Undefined -> Object.putProperty(x, "undefined", value)
    | TypeCodes.Object
    | TypeCodes.Function ->
      let mutable v = Object.defaultValue(index.Object)
      Object.putIndex(x, &v, value)

    | TypeCodes.Bool ->
      Object.putProperty(x, TypeConverter.toString index.Bool, value)

    | TypeCodes.Clr -> 
      Object.putProperty(x, TypeConverter.toString index.Clr, value)

    | _ -> failwith "Que?"

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:IjsStr, value:IjsBox byref) : IjsBox = 
    let mutable i = Index.Min
    if Utils.isStringIndex(index, &i) 
      then Object.putIndex(x, i, &value)
      else 
        if x.Class=Classes.Array && index="length" 
          then Object.putLength(x, &value)
          else Object.putProperty(x, index, &value)

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:IjsStr, value:IjsBool) : IjsBool = 
    let mutable i = Index.Min
    if Utils.isStringIndex(index, &i) 
      then Object.putIndex(x, i, value)
      else 
        if x.Class=Classes.Array && index="length" 
          then Object.putLength(x, value)
          else Object.putProperty(x, index, value)

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:IjsStr, value:IjsNum) : IjsNum = 
    let mutable i = Index.Min
    if Utils.isStringIndex(index, &i) 
      then Object.putIndex(x, i, value)
      else 
        if x.Class=Classes.Array && index="length" 
          then Object.putLength(x, value)
          else Object.putProperty(x, index, value)

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:IjsStr, value:HostObject) : HostObject = 
    let mutable i = Index.Min
    if Utils.isStringIndex(index, &i) 
      then Object.putIndex(x, i, value)
      else 
        if x.Class=Classes.Array && index="length" 
          then Object.putLength(x, value)
          else Object.putProperty(x, index, value)

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:IjsStr, value:Undefined) : Undefined = 
    let mutable i = Index.Min
    if Utils.isStringIndex(index, &i) 
      then Object.putIndex(x, i, value)
      else 
        if x.Class=Classes.Array && index="length" 
          then Object.putLength(x, value)
          else Object.putProperty(x, index, value)

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:IjsStr, value:IjsStr) : IjsStr = 
    let mutable i = Index.Min
    if Utils.isStringIndex(index, &i) 
      then Object.putIndex(x, i, value)
      else 
        if x.Class=Classes.Array && index="length" 
          then Object.putLength(x, value)
          else Object.putProperty(x, index, value)

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:IjsStr, value:IjsObj) : IjsObj = 
    let mutable i = Index.Min
    if Utils.isStringIndex(index, &i) 
      then Object.putIndex(x, i, value)
      else 
        if x.Class=Classes.Array && index="length" 
          then Object.putLength(x, value)
          else Object.putProperty(x, index, value)

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:IjsStr, value:IjsFunc) : IjsFunc = 
    let mutable i = Index.Min
    if Utils.isStringIndex(index, &i) 
      then Object.putIndex(x, i, value)
      else 
        if x.Class=Classes.Array && index="length" 
          then Object.putLength(x, value)
          else Object.putProperty(x, index, value)

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:IjsNum, value:IjsBox byref) : IjsBox = 
    let i = uint32 index
    if double i = index
      then Object.putIndex(x, i, &value)
      else Object.putProperty(x, TypeConverter.toString index, &value)

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:IjsNum, value:IjsBool) : IjsBool = 
    let i = uint32 index
    if double i = index
      then Object.putIndex(x, i, value)
      else Object.putProperty(x, TypeConverter.toString index, value)

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:IjsNum, value:IjsNum) : IjsNum = 
    let i = uint32 index
    if double i = index
      then Object.putIndex(x, i, value)
      else Object.putProperty(x, TypeConverter.toString index, value)

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:IjsNum, value:HostObject) : HostObject = 
    let i = uint32 index
    if double i = index
      then Object.putIndex(x, i, value)
      else Object.putProperty(x, TypeConverter.toString index, value)

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:IjsNum, value:Undefined) : Undefined = 
    let i = uint32 index
    if double i = index
      then Object.putIndex(x, i, value)
      else Object.putProperty(x, TypeConverter.toString index, value)

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:IjsNum, value:IjsStr) : IjsStr = 
    let i = uint32 index
    if double i = index
      then Object.putIndex(x, i, value)
      else Object.putProperty(x, TypeConverter.toString index, value)

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:IjsNum, value:IjsObj) : IjsObj = 
    let i = uint32 index
    if double i = index
      then Object.putIndex(x, i, value)
      else Object.putProperty(x, TypeConverter.toString index, value)

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:IjsNum, value:IjsFunc) : IjsFunc = 
    let i = uint32 index
    if double i = index
      then Object.putIndex(x, i, value)
      else Object.putProperty(x, TypeConverter.toString index, value)

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, ui:uint32, value:IjsBox byref) : IjsBox =
    if ui > Index.Max then Object.initSparse x
    if Utils.isDense x then
      if ui < uint32 x.IndexValues.Length then
        x.IndexValues.[(int ui)] <- value
      else
        if ui > 255u && ui/2u > x.IndexLength then
          Object.initSparse x
          x.IndexSparse.[ui] <- value
        else
          Object.expandIndexStorage(x, int ui)
          x.IndexValues.[(int ui)] <- value
    else
      x.IndexSparse.[ui] <- value

    if ui > x.IndexLength then
      x.IndexLength <- ui + 1u
      Object.putLength(x, double (ui + 1u)) |> ignore

    value

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, ui:uint32, value:IjsBool) : IjsBool =
    if ui > Index.Max then Object.initSparse x
    if Utils.isDense x then
      if ui < uint32 x.IndexValues.Length then
        Utils.setIjsBoolInArray x.IndexValues (int ui) value
      else
        if ui > 255u && ui/2u > x.IndexLength then
          Object.initSparse x
          x.IndexSparse.[ui] <- Utils.boxIjsBool value
        else
          Object.expandIndexStorage(x, int ui)
          Utils.setIjsBoolInArray x.IndexValues (int ui) value
    else
      x.IndexSparse.[ui] <- Utils.boxIjsBool value

    if ui > x.IndexLength then
      x.IndexLength <- ui + 1u
      Object.putLength(x, double (ui + 1u)) |> ignore

    value

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, ui:uint32, value:IjsNum) : IjsNum =
    if ui > Index.Max then Object.initSparse x
    if Utils.isDense x then
      if ui < uint32 x.IndexValues.Length then
        Utils.setIjsNumInArray x.IndexValues (int ui) value
      else
        if ui > 255u && ui/2u > x.IndexLength then
          Object.initSparse x
          x.IndexSparse.[ui] <- Utils.boxIjsNum value
        else
          Object.expandIndexStorage(x, int ui)
          Utils.setIjsNumInArray x.IndexValues (int ui) value
    else
      x.IndexSparse.[ui] <- Utils.boxIjsNum value

    if ui > x.IndexLength then
      x.IndexLength <- ui + 1u
      Object.putLength(x, double (ui + 1u)) |> ignore

    value

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, ui:uint32, value:HostObject) : HostObject =
    if ui > Index.Max then Object.initSparse x
    if Utils.isDense x then
      if ui < uint32 x.IndexValues.Length then
        Utils.setHostObjectInArray x.IndexValues (int ui) value
      else
        if ui > 255u && ui/2u > x.IndexLength then
          Object.initSparse x
          x.IndexSparse.[ui] <- Utils.boxHostObject value
        else
          Object.expandIndexStorage(x, int ui)
          Utils.setHostObjectInArray x.IndexValues (int ui) value
    else
      x.IndexSparse.[ui] <- Utils.boxHostObject value

    if ui > x.IndexLength then
      x.IndexLength <- ui + 1u
      Object.putLength(x, double (ui + 1u)) |> ignore

    value

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, ui:uint32, value:Undefined) : Undefined =
    if ui > Index.Max then Object.initSparse x
    if Utils.isDense x then
      if ui < uint32 x.IndexValues.Length then
        Utils.setUndefinedInArray x.IndexValues (int ui) value
      else
        if ui > 255u && ui/2u > x.IndexLength then
          Object.initSparse x
          x.IndexSparse.[ui] <- Utils.boxUndefined value
        else
          Object.expandIndexStorage(x, int ui)
          Utils.setUndefinedInArray x.IndexValues (int ui) value
    else
      x.IndexSparse.[ui] <- Utils.boxUndefined value

    if ui > x.IndexLength then
      x.IndexLength <- ui + 1u
      Object.putLength(x, double (ui + 1u)) |> ignore

    value

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, ui:uint32, value:IjsStr) : IjsStr =
    if ui > Index.Max then Object.initSparse x
    if Utils.isDense x then
      if ui < uint32 x.IndexValues.Length then
        Utils.setIjsStrInArray x.IndexValues (int ui) value
      else
        if ui > 255u && ui/2u > x.IndexLength then
          Object.initSparse x
          x.IndexSparse.[ui] <- Utils.boxIjsStr value
        else
          Object.expandIndexStorage(x, int ui)
          Utils.setIjsStrInArray x.IndexValues (int ui) value
    else
      x.IndexSparse.[ui] <- Utils.boxIjsStr value

    if ui > x.IndexLength then
      x.IndexLength <- ui + 1u
      Object.putLength(x, double (ui + 1u)) |> ignore

    value

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, ui:uint32, value:IjsObj) : IjsObj =
    if ui > Index.Max then Object.initSparse x
    if Utils.isDense x then
      if ui < uint32 x.IndexValues.Length then
        Utils.setIjsObjInArray x.IndexValues (int ui) value
      else
        if ui > 255u && ui/2u > x.IndexLength then
          Object.initSparse x
          x.IndexSparse.[ui] <- Utils.boxIjsObj value
        else
          Object.expandIndexStorage(x, int ui)
          Utils.setIjsObjInArray x.IndexValues (int ui) value
    else
      x.IndexSparse.[ui] <- Utils.boxIjsObj value

    if ui > x.IndexLength then
      x.IndexLength <- ui + 1u
      Object.putLength(x, double (ui + 1u)) |> ignore

    value

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, ui:uint32, value:IjsFunc) : IjsFunc =
    if ui > Index.Max then Object.initSparse x
    if Utils.isDense x then
      if ui < uint32 x.IndexValues.Length then
        Utils.setIjsFuncInArray x.IndexValues (int ui) value
      else
        if ui > 255u && ui/2u > x.IndexLength then
          Object.initSparse x
          x.IndexSparse.[ui] <- Utils.boxIjsFunc value
        else
          Object.expandIndexStorage(x, int ui)
          Utils.setIjsFuncInArray x.IndexValues (int ui) value
    else
      x.IndexSparse.[ui] <- Utils.boxIjsFunc value

    if ui > x.IndexLength then
      x.IndexLength <- ui + 1u
      Object.putLength(x, double (ui + 1u)) |> ignore

    value

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
and [<Sealed>] Function_Gen =
  
  static member call (f:IjsFunc,t) =
    let c = f.Compiler
    let c = c.compileAs<Func<IjsFunc,IjsObj,IjsBox>>(f)
    c.Invoke(f,t)
  
  static member call (f:IjsFunc,t,a0:'a0,a1:'a1) =
    let c = f.Compiler
    let c = c.compileAs<Func<IjsFunc,IjsObj,'a0,IjsBox>>(f)
    c.Invoke(f,t,a0)
  
  static member call (f:IjsFunc,t,a0:'a0,a1:'a1,a2:'a2) =
    let c = f.Compiler
    let c = c.compileAs<Func<IjsFunc,IjsObj,'a0,'a1,IjsBox>>(f)
    c.Invoke(f,t,a0,a1)
  
  static member call (f:IjsFunc,t,a0:'a0,a1:'a1,a2:'a2,a3:'a3) =
    let c = f.Compiler
    let c = c.compileAs<Func<IjsFunc,IjsObj,'a0,'a1,'a2,IjsBox>>(f)
    c.Invoke(f,t,a0,a1,a2)
  
  static member call (f:IjsFunc,t,a0:'a0,a1:'a1,a2:'a2,a3:'a3,a4:'a4) =
    let c = f.Compiler
    let c = c.compileAs<Func<IjsFunc,IjsObj,'a0,'a1,'a2,'a3,IjsBox>>(f)
    c.Invoke(f,t,a0,a1,a2,a3)
  
  static member call (f:IjsFunc,t,a0:'a0,a1:'a1,a2:'a2,a3:'a3,a4:'a4,a5:'a5) =
    let c = f.Compiler
    let c = c.compileAs<Func<IjsFunc,IjsObj,'a0,'a1,'a2,'a3,'a4,IjsBox>>(f)
    c.Invoke(f,t,a0,a1,a2,a3,a4)
  
  static member call (f:IjsFunc,t,a0:'a0,a1:'a1,a2:'a2,a3:'a3,a4:'a4,a5:'a5,a6:'a6) =
    let c = f.Compiler
    let c = c.compileAs<Func<IjsFunc,IjsObj,'a0,'a1,'a2,'a3,'a4,'a5,IjsBox>>(f)
    c.Invoke(f,t,a0,a1,a2,a3,a4,a5)
  
  static member call (f:IjsFunc,t,a0:'a0,a1:'a1,a2:'a2,a3:'a3,a4:'a4,a5:'a5,a6:'a6,a7:'a7) =
    let c = f.Compiler
    let c = c.compileAs<Func<IjsFunc,IjsObj,'a0,'a1,'a2,'a3,'a4,'a5,'a6,IjsBox>>(f)
    c.Invoke(f,t,a0,a1,a2,a3,a4,a5,a6)
  
  static member call (f:IjsFunc,t,a0:'a0,a1:'a1,a2:'a2,a3:'a3,a4:'a4,a5:'a5,a6:'a6,a7:'a7,a8:'a8) =
    let c = f.Compiler
    let c = c.compileAs<Func<IjsFunc,IjsObj,'a0,'a1,'a2,'a3,'a4,'a5,'a6,'a7,IjsBox>>(f)
    c.Invoke(f,t,a0,a1,a2,a3,a4,a5,a6,a7)

  static member construct (f:IjsFunc,t:IjsObj) =
    let c = f.Compiler
    let c = c.compileAs<Func<IjsFunc,IjsObj,IjsBox>>(f)

    match f.ConstructorMode with
    | ConstructorModes.Host -> c.Invoke(f,null)
    | ConstructorModes.User -> 
      let o = Environment.createObject(f.Env)
      let prototype = Object.getProperty(f, "prototype")
      let prototype = 
        match prototype.Type with
        | TypeCodes.Function
        | TypeCodes.Object -> prototype.Object
        | _ -> f.Env.Object_prototype

      o.Prototype <- prototype
      c.Invoke(f,o)

    | _ -> Errors.runtime "Can't call [[Construct]] on non-constructor"

  static member construct (f:IjsFunc,t:IjsObj,a0:'a0,a1:'a1) =
    let c = f.Compiler
    let c = c.compileAs<Func<IjsFunc,IjsObj,'a0,IjsBox>>(f)

    match f.ConstructorMode with
    | ConstructorModes.Host -> c.Invoke(f,null,a0)
    | ConstructorModes.User -> 
      let o = Environment.createObject(f.Env)
      let prototype = Object.getProperty(f, "prototype")
      let prototype = 
        match prototype.Type with
        | TypeCodes.Function
        | TypeCodes.Object -> prototype.Object
        | _ -> f.Env.Object_prototype

      o.Prototype <- prototype
      c.Invoke(f,o,a0)

    | _ -> Errors.runtime "Can't call [[Construct]] on non-constructor"

  static member construct (f:IjsFunc,t:IjsObj,a0:'a0,a1:'a1,a2:'a2) =
    let c = f.Compiler
    let c = c.compileAs<Func<IjsFunc,IjsObj,'a0,'a1,IjsBox>>(f)

    match f.ConstructorMode with
    | ConstructorModes.Host -> c.Invoke(f,null,a0,a1)
    | ConstructorModes.User -> 
      let o = Environment.createObject(f.Env)
      let prototype = Object.getProperty(f, "prototype")
      let prototype = 
        match prototype.Type with
        | TypeCodes.Function
        | TypeCodes.Object -> prototype.Object
        | _ -> f.Env.Object_prototype

      o.Prototype <- prototype
      c.Invoke(f,o,a0,a1)

    | _ -> Errors.runtime "Can't call [[Construct]] on non-constructor"

  static member construct (f:IjsFunc,t:IjsObj,a0:'a0,a1:'a1,a2:'a2,a3:'a3) =
    let c = f.Compiler
    let c = c.compileAs<Func<IjsFunc,IjsObj,'a0,'a1,'a2,IjsBox>>(f)

    match f.ConstructorMode with
    | ConstructorModes.Host -> c.Invoke(f,null,a0,a1,a2)
    | ConstructorModes.User -> 
      let o = Environment.createObject(f.Env)
      let prototype = Object.getProperty(f, "prototype")
      let prototype = 
        match prototype.Type with
        | TypeCodes.Function
        | TypeCodes.Object -> prototype.Object
        | _ -> f.Env.Object_prototype

      o.Prototype <- prototype
      c.Invoke(f,o,a0,a1,a2)

    | _ -> Errors.runtime "Can't call [[Construct]] on non-constructor"

  static member construct (f:IjsFunc,t:IjsObj,a0:'a0,a1:'a1,a2:'a2,a3:'a3,a4:'a4) =
    let c = f.Compiler
    let c = c.compileAs<Func<IjsFunc,IjsObj,'a0,'a1,'a2,'a3,IjsBox>>(f)

    match f.ConstructorMode with
    | ConstructorModes.Host -> c.Invoke(f,null,a0,a1,a2,a3)
    | ConstructorModes.User -> 
      let o = Environment.createObject(f.Env)
      let prototype = Object.getProperty(f, "prototype")
      let prototype = 
        match prototype.Type with
        | TypeCodes.Function
        | TypeCodes.Object -> prototype.Object
        | _ -> f.Env.Object_prototype

      o.Prototype <- prototype
      c.Invoke(f,o,a0,a1,a2,a3)

    | _ -> Errors.runtime "Can't call [[Construct]] on non-constructor"

  static member construct (f:IjsFunc,t:IjsObj,a0:'a0,a1:'a1,a2:'a2,a3:'a3,a4:'a4,a5:'a5) =
    let c = f.Compiler
    let c = c.compileAs<Func<IjsFunc,IjsObj,'a0,'a1,'a2,'a3,'a4,IjsBox>>(f)

    match f.ConstructorMode with
    | ConstructorModes.Host -> c.Invoke(f,null,a0,a1,a2,a3,a4)
    | ConstructorModes.User -> 
      let o = Environment.createObject(f.Env)
      let prototype = Object.getProperty(f, "prototype")
      let prototype = 
        match prototype.Type with
        | TypeCodes.Function
        | TypeCodes.Object -> prototype.Object
        | _ -> f.Env.Object_prototype

      o.Prototype <- prototype
      c.Invoke(f,o,a0,a1,a2,a3,a4)

    | _ -> Errors.runtime "Can't call [[Construct]] on non-constructor"

  static member construct (f:IjsFunc,t:IjsObj,a0:'a0,a1:'a1,a2:'a2,a3:'a3,a4:'a4,a5:'a5,a6:'a6) =
    let c = f.Compiler
    let c = c.compileAs<Func<IjsFunc,IjsObj,'a0,'a1,'a2,'a3,'a4,'a5,IjsBox>>(f)

    match f.ConstructorMode with
    | ConstructorModes.Host -> c.Invoke(f,null,a0,a1,a2,a3,a4,a5)
    | ConstructorModes.User -> 
      let o = Environment.createObject(f.Env)
      let prototype = Object.getProperty(f, "prototype")
      let prototype = 
        match prototype.Type with
        | TypeCodes.Function
        | TypeCodes.Object -> prototype.Object
        | _ -> f.Env.Object_prototype

      o.Prototype <- prototype
      c.Invoke(f,o,a0,a1,a2,a3,a4,a5)

    | _ -> Errors.runtime "Can't call [[Construct]] on non-constructor"

  static member construct (f:IjsFunc,t:IjsObj,a0:'a0,a1:'a1,a2:'a2,a3:'a3,a4:'a4,a5:'a5,a6:'a6,a7:'a7) =
    let c = f.Compiler
    let c = c.compileAs<Func<IjsFunc,IjsObj,'a0,'a1,'a2,'a3,'a4,'a5,'a6,IjsBox>>(f)

    match f.ConstructorMode with
    | ConstructorModes.Host -> c.Invoke(f,null,a0,a1,a2,a3,a4,a5,a6)
    | ConstructorModes.User -> 
      let o = Environment.createObject(f.Env)
      let prototype = Object.getProperty(f, "prototype")
      let prototype = 
        match prototype.Type with
        | TypeCodes.Function
        | TypeCodes.Object -> prototype.Object
        | _ -> f.Env.Object_prototype

      o.Prototype <- prototype
      c.Invoke(f,o,a0,a1,a2,a3,a4,a5,a6)

    | _ -> Errors.runtime "Can't call [[Construct]] on non-constructor"

  static member construct (f:IjsFunc,t:IjsObj,a0:'a0,a1:'a1,a2:'a2,a3:'a3,a4:'a4,a5:'a5,a6:'a6,a7:'a7,a8:'a8) =
    let c = f.Compiler
    let c = c.compileAs<Func<IjsFunc,IjsObj,'a0,'a1,'a2,'a3,'a4,'a5,'a6,'a7,IjsBox>>(f)

    match f.ConstructorMode with
    | ConstructorModes.Host -> c.Invoke(f,null,a0,a1,a2,a3,a4,a5,a6,a7)
    | ConstructorModes.User -> 
      let o = Environment.createObject(f.Env)
      let prototype = Object.getProperty(f, "prototype")
      let prototype = 
        match prototype.Type with
        | TypeCodes.Function
        | TypeCodes.Object -> prototype.Object
        | _ -> f.Env.Object_prototype

      o.Prototype <- prototype
      c.Invoke(f,o,a0,a1,a2,a3,a4,a5,a6,a7)

    | _ -> Errors.runtime "Can't call [[Construct]] on non-constructor"

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
and [<Sealed>] PutPropertyCache_Gen =

  //----------------------------------------------------------------------------
  static member update (x:IronJS.PutPropertyCache, o:IjsObj, value:IjsBox byref) =
    match o.PropertyClassId with
    | PropertyClassTypes.Dynamic -> 
      Object.putProperty(o, x.PropertyName, &value)

    | _   -> 
      let mutable i = -1
      if Object.getOwnPropertyIndex(o, x.PropertyName, &i) then
        x.PropertyIndex   <- i
        x.PropertyClassId <- o.PropertyClassId

      Object.putProperty(o, x.PropertyName, &value)

  //----------------------------------------------------------------------------
  static member update (x:IronJS.PutPropertyCache, o:IjsObj, value:IjsBool) =
    match o.PropertyClassId with
    | PropertyClassTypes.Dynamic -> 
      Object.putProperty(o, x.PropertyName, value)

    | _   -> 
      let mutable i = -1
      if Object.getOwnPropertyIndex(o, x.PropertyName, &i) then
        x.PropertyIndex   <- i
        x.PropertyClassId <- o.PropertyClassId

      Object.putProperty(o, x.PropertyName, value)

  //----------------------------------------------------------------------------
  static member update (x:IronJS.PutPropertyCache, o:IjsObj, value:IjsNum) =
    match o.PropertyClassId with
    | PropertyClassTypes.Dynamic -> 
      Object.putProperty(o, x.PropertyName, value)

    | _   -> 
      let mutable i = -1
      if Object.getOwnPropertyIndex(o, x.PropertyName, &i) then
        x.PropertyIndex   <- i
        x.PropertyClassId <- o.PropertyClassId

      Object.putProperty(o, x.PropertyName, value)

  //----------------------------------------------------------------------------
  static member update (x:IronJS.PutPropertyCache, o:IjsObj, value:HostObject) =
    match o.PropertyClassId with
    | PropertyClassTypes.Dynamic -> 
      Object.putProperty(o, x.PropertyName, value)

    | _   -> 
      let mutable i = -1
      if Object.getOwnPropertyIndex(o, x.PropertyName, &i) then
        x.PropertyIndex   <- i
        x.PropertyClassId <- o.PropertyClassId

      Object.putProperty(o, x.PropertyName, value)

  //----------------------------------------------------------------------------
  static member update (x:IronJS.PutPropertyCache, o:IjsObj, value:Undefined) =
    match o.PropertyClassId with
    | PropertyClassTypes.Dynamic -> 
      Object.putProperty(o, x.PropertyName, value)

    | _   -> 
      let mutable i = -1
      if Object.getOwnPropertyIndex(o, x.PropertyName, &i) then
        x.PropertyIndex   <- i
        x.PropertyClassId <- o.PropertyClassId

      Object.putProperty(o, x.PropertyName, value)

  //----------------------------------------------------------------------------
  static member update (x:IronJS.PutPropertyCache, o:IjsObj, value:IjsStr) =
    match o.PropertyClassId with
    | PropertyClassTypes.Dynamic -> 
      Object.putProperty(o, x.PropertyName, value)

    | _   -> 
      let mutable i = -1
      if Object.getOwnPropertyIndex(o, x.PropertyName, &i) then
        x.PropertyIndex   <- i
        x.PropertyClassId <- o.PropertyClassId

      Object.putProperty(o, x.PropertyName, value)

  //----------------------------------------------------------------------------
  static member update (x:IronJS.PutPropertyCache, o:IjsObj, value:IjsObj) =
    match o.PropertyClassId with
    | PropertyClassTypes.Dynamic -> 
      Object.putProperty(o, x.PropertyName, value)

    | _   -> 
      let mutable i = -1
      if Object.getOwnPropertyIndex(o, x.PropertyName, &i) then
        x.PropertyIndex   <- i
        x.PropertyClassId <- o.PropertyClassId

      Object.putProperty(o, x.PropertyName, value)

  //----------------------------------------------------------------------------
  static member update (x:IronJS.PutPropertyCache, o:IjsObj, value:IjsFunc) =
    match o.PropertyClassId with
    | PropertyClassTypes.Dynamic -> 
      Object.putProperty(o, x.PropertyName, value)

    | _   -> 
      let mutable i = -1
      if Object.getOwnPropertyIndex(o, x.PropertyName, &i) then
        x.PropertyIndex   <- i
        x.PropertyClassId <- o.PropertyClassId

      Object.putProperty(o, x.PropertyName, value)
