<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".fs" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<# 
var types = new [] { "IjsBool", "IjsNum", "HostObject", "Undefined", "IjsStr", "IjsObj", "IjsFunc" }; 
var typesWithBox = new [] { "IjsBox", "IjsBool", "IjsNum", "HostObject", "Undefined", "IjsStr", "IjsObj", "IjsFunc" }; 
Func<string, string> printArg = (x) => x == "IjsBox" ? "IjsBox byref" : x;
Func<string, string, string, string, string> arraySetter = (typ, array, index, value) => 
{
	if(typ == "IjsBox") {
		return array + ".[" + index + "] <- " + value;
	} else {
		return "Utils.set" + typ + "InArray " + array + " " + index + " " + value;
	}
};
Func<string, string, string> box = (type, value) => {
	if(type == "IjsBox")  {
		return value;
	} else {
		return "Utils.box" + type + " " + value;
	}
};

Func<string, string> printVal = (x) => x == "IjsBox" ? "&value" : "value";
#>
namespace IronJS.Api

//------------------------------------------------------------------------------
// This file is generated by T4 and will be reset on each compile
//------------------------------------------------------------------------------

open System
open IronJS

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
type [<Sealed>] Object = 
<# foreach(var type in typesWithBox) { #>

  //----------------------------------------------------------------------------
  static member putProperty (x:IjsObj, name:IjsStr, value:<#= printArg(type) #>) =
    let index = Object.createPropertyIndex(x, name)
    <#= arraySetter(type, "x.PropertyValues", "index", "value") #>
    value
<# } #>
<# foreach(var type in typesWithBox) { #>

  //----------------------------------------------------------------------------
  static member putLength (x:IjsObj, value:<#= printArg(type) #>) : <#= type #> =
    Object.updateLength(x, TypeConverter.toNumber <#= printVal(type) #>)
    Object.putProperty(x, "length", <#= printVal(type) #>)
<# } #>
<# foreach(var type in typesWithBox) { #>

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:Box byref, value:<#= printArg(type) #>) : <#= type #> = 
    match index.Type with
    | TypeCodes.Number -> Object.putIndex(x, index.Double, <#= printVal(type) #>)
    | TypeCodes.String -> Object.putIndex(x, index.String, <#= printVal(type) #>)
    | TypeCodes.Undefined -> Object.putProperty(x, "undefined", <#= printVal(type) #>)
    | TypeCodes.Bool ->
      let name = if index.Bool then "true" else "false"
      Object.putProperty(x, name, <#= printVal(type) #>)
  
    | TypeCodes.Clr -> 
      if index.Clr = null 
        then Object.putProperty(x, "null", <#= printVal(type) #>)
        else Object.putProperty(x, index.Clr.ToString(), <#= printVal(type) #>)

    | TypeCodes.Object
    | TypeCodes.Function ->
      let mutable v = Object.defaultValue(index.Object)
      Object.putIndex(x, &v, <#= printVal(type) #>)

    | _ -> failwith "Que?"
<# } #>
<# foreach(var type in typesWithBox) { #>

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:IjsStr, value:<#= printArg(type) #>) : <#= type #> = 
    let mutable i = Index.Min
    if Utils.isStringIndex(index, &i) 
      then Object.putIndex(x, i, <#= printVal(type) #>)
      else 
        if x.Class=Classes.Array && index="length" 
          then Object.putLength(x, <#= printVal(type) #>)
          else Object.putProperty(x, index, <#= printVal(type) #>)
<# } #>
<# foreach(var type in typesWithBox) { #>

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:IjsNum, value:<#= printArg(type) #>) : <#= type #> = 
    let i = uint32 index
    if double i = index
      then Object.putIndex(x, i, <#= printVal(type) #>)
      else Object.putProperty(x, TypeConverter.toString index, <#= printVal(type) #>)
<# } #>
<# foreach(var type in typesWithBox) { #>

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, ui:uint32, value:<#= printArg(type) #>) : <#= type #> =
    if ui > Index.Max then Object.initSparse x
    if Utils.isDense x then
      if ui < uint32 x.IndexValues.Length then
        <#= arraySetter(type, "x.IndexValues", "(int ui)", "value") #>
      else
        if ui > 255u && ui/2u > x.IndexLength then
          Object.initSparse x
          x.IndexSparse.[ui] <- <#= box(type, "value") #>
        else
          Object.expandIndexStorage(x, int ui)
          <#= arraySetter(type, "x.IndexValues", "(int ui)", "value") #>
    else
      x.IndexSparse.[ui] <- <#= box(type, "value") #>

    if ui > x.IndexLength then
      x.IndexLength <- ui + 1u
      Object.updateLength(x, double ui)

    value
<# } #>

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
and [<Sealed>] PutPropertyCache_Gen =
<# foreach(var type in typesWithBox) { #>

  //----------------------------------------------------------------------------
  static member update (x:IronJS.PutPropertyCache, o:IjsObj, value:<#= printArg(type) #>) =
    match o.PropertyClassId with
    | PropertyClassTypes.Dynamic -> 
      Object.putProperty(o, x.PropertyName, <#= printVal(type) #>)

    | _   -> 
      let mutable i = -1
      if Object.getOwnPropertyIndex(o, x.PropertyName, &i) then
        x.PropertyIndex   <- i
        x.PropertyClassId <- o.PropertyClassId

      Object.putProperty(o, x.PropertyName, <#= printVal(type) #>)
<# } #>