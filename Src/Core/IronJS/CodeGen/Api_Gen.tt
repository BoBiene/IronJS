<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".fs" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<# 
var types = new [] { "IjsBool", "IjsNum", "HostObject", "Undefined", "IjsStr", "IjsObj", "IjsFunc" }; 
var typesWithBox = new [] { "IjsBox", "IjsBool", "IjsNum", "HostObject", "Undefined", "IjsStr", "IjsObj", "IjsFunc" }; 
Func<string, string> printArg = (x) => x == "IjsBox" ? "IjsBox byref" : x;
Func<string, string, string, string, string> arraySetter = (typ, array, index, value) => 
{
	if(typ == "IjsBox") {
		return array + ".[" + index + "] <- " + value;
	} else {
		return "Utils.set" + typ + "InArray " + array + " " + index + " " + value;
	}
};
Func<string, string, string> box = (type, value) => {
	if(type == "IjsBox")  {
		return value;
	} else {
		return "Utils.box" + type + " " + value;
	}
};

Func<string, string> printVal = (x) => x == "IjsBox" ? "&value" : "value";

Func<int, string> buildArgList = (n) => {
	if(n == 0) {
		return "";
	} else {
		var lst = new List<string>();
		for(var i = 0; i <= n; ++i) {
			lst.Add(String.Format("a{0}:'a{0}", i));
		}
		return "," + String.Join(",", lst);
	}
};

Func<int, string> buildCallList = (n) => {
	if(n == 0) {
		return "";
	} else {
		var lst = new List<string>();
		for(var i = 0; i < n; ++i) {
			lst.Add(String.Format("a{0}", i));
		}
		return "," + String.Join(",", lst);
		}
};

Func<int, string> buildTypeList = (n) => {
	if(n == 0) {
		return "";
	} else {
		var lst = new List<string>();
		for(var i = 0; i < n; ++i) {
			lst.Add(String.Format("'a{0}", i));
		}
		return "," + String.Join(",", lst);
	}
};

#>
namespace IronJS.Api

//------------------------------------------------------------------------------
// This file is generated by T4 and will be reset on each compile
//------------------------------------------------------------------------------

open System
open IronJS

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
type [<Sealed>] Object = 
<# foreach(var type in typesWithBox) { #>

  //----------------------------------------------------------------------------
  static member putProperty (x:IjsObj, name:IjsStr, value:<#= printArg(type) #>) =
    let index = Object.createPropertyIndex(x, name)
    <#= arraySetter(type, "x.PropertyValues", "index", "value") #>
    value
<# } #>
<# foreach(var type in typesWithBox) { #>

  //----------------------------------------------------------------------------
  static member putLength (x:IjsObj, value:<#= printArg(type) #>) : <#= type #> =
    Object.updateLength(x, TypeConverter.toNumber <#= printVal(type) #>)
    Object.putProperty(x, "length", <#= printVal(type) #>)
<# } #>
<# foreach(var type in typesWithBox) { #>

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:Box byref, value:<#= printArg(type) #>) : <#= type #> = 
    match index.Type with
    | TypeCodes.Number -> Object.putIndex(x, index.Double, <#= printVal(type) #>)
    | TypeCodes.String -> Object.putIndex(x, index.String, <#= printVal(type) #>)
    | TypeCodes.Undefined -> Object.putProperty(x, "undefined", <#= printVal(type) #>)
    | TypeCodes.Object
    | TypeCodes.Function ->
      let mutable v = Object.defaultValue(index.Object)
      Object.putIndex(x, &v, <#= printVal(type) #>)

    | TypeCodes.Bool ->
      Object.putProperty(x, TypeConverter.toString index.Bool, <#= printVal(type) #>)

    | TypeCodes.Clr -> 
      Object.putProperty(x, TypeConverter.toString index.Clr, <#= printVal(type) #>)

    | _ -> failwith "Que?"
<# } #>
<# foreach(var type in typesWithBox) { #>

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:IjsStr, value:<#= printArg(type) #>) : <#= type #> = 
    let mutable i = Index.Min
    if Utils.isStringIndex(index, &i) 
      then Object.putIndex(x, i, <#= printVal(type) #>)
      else 
        if x.Class=Classes.Array && index="length" 
          then Object.putLength(x, <#= printVal(type) #>)
          else Object.putProperty(x, index, <#= printVal(type) #>)
<# } #>
<# foreach(var type in typesWithBox) { #>

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, index:IjsNum, value:<#= printArg(type) #>) : <#= type #> = 
    let i = uint32 index
    if double i = index
      then Object.putIndex(x, i, <#= printVal(type) #>)
      else Object.putProperty(x, TypeConverter.toString index, <#= printVal(type) #>)
<# } #>
<# foreach(var type in typesWithBox) { #>

  //----------------------------------------------------------------------------
  static member putIndex (x:IjsObj, ui:uint32, value:<#= printArg(type) #>) : <#= type #> =
    if ui > Index.Max then Object.initSparse x
    if Utils.isDense x then
      if ui < uint32 x.IndexValues.Length then
        <#= arraySetter(type, "x.IndexValues", "(int ui)", "value") #>
      else
        if ui > 255u && ui/2u > x.IndexLength then
          Object.initSparse x
          x.IndexSparse.[ui] <- <#= box(type, "value") #>
        else
          Object.expandIndexStorage(x, int ui)
          <#= arraySetter(type, "x.IndexValues", "(int ui)", "value") #>
    else
      x.IndexSparse.[ui] <- <#= box(type, "value") #>

    if ui > x.IndexLength then
      x.IndexLength <- ui + 1u
      Object.putLength(x, double (ui + 1u)) |> ignore

    value
<# } #>

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
and [<Sealed>] Function_Gen =
<# for(var i = 0; i <= 8; ++i) { #>
  
  static member call (f:IjsFunc,t<#= buildArgList(i) #>) =
    let c = f.Compiler
    let c = c.compileAs<Func<IjsFunc,IjsObj<#= buildTypeList(i) #>,IjsBox>>(f)
    c.Invoke(f,t<#= buildCallList(i) #>)
<# } #>
<# for(var i = 0; i <= 8; ++i) { #>

  static member construct (f:IjsFunc,t:IjsObj<#= buildArgList(i) #>) =
    let c = f.Compiler
    let c = c.compileAs<Func<IjsFunc,IjsObj<#= buildTypeList(i) #>,IjsBox>>(f)

    match f.ConstructorMode with
    | ConstructorModes.Host -> c.Invoke(f,null<#= buildCallList(i) #>)
    | ConstructorModes.User -> 
      let o = Environment.createObject(f.Env)
      let prototype = Object.getProperty(f, "prototype")
      let prototype = 
        match prototype.Type with
        | TypeCodes.Function
        | TypeCodes.Object -> prototype.Object
        | _ -> f.Env.Object_prototype

      o.Prototype <- prototype
      c.Invoke(f,o<#= buildCallList(i) #>)

    | _ -> Errors.runtime "Can't call [[Construct]] on non-constructor"
<# } #>

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
and [<Sealed>] PutPropertyCache_Gen =
<# foreach(var type in typesWithBox) { #>

  //----------------------------------------------------------------------------
  static member update (x:IronJS.PutPropertyCache, o:IjsObj, value:<#= printArg(type) #>) =
    match o.PropertyClassId with
    | PropertyClassTypes.Dynamic -> 
      Object.putProperty(o, x.PropertyName, <#= printVal(type) #>)

    | _   -> 
      let mutable i = -1
      if Object.getOwnPropertyIndex(o, x.PropertyName, &i) then
        x.PropertyIndex   <- i
        x.PropertyClassId <- o.PropertyClassId

      Object.putProperty(o, x.PropertyName, <#= printVal(type) #>)
<# } #>